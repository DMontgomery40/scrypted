"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StorageSettings = void 0;
const _1 = __importStar(require("."));
const { systemManager } = _1.default;
function parseValue(value, setting, readDefaultValue, rawDevice) {
    const type = setting.multiple ? 'array' : setting.type;
    if (type === 'boolean') {
        if (value === 'true')
            return true;
        if (value === 'false')
            return false;
        return readDefaultValue() || false;
    }
    if (type === 'number') {
        return parseFloat(value) || readDefaultValue() || 0;
    }
    if (type === 'integer') {
        return parseInt(value) || readDefaultValue() || 0;
    }
    if (type === 'array') {
        try {
            return JSON.parse(value);
        }
        catch (e) {
            return readDefaultValue() || [];
        }
    }
    if (type === 'device') {
        if (rawDevice)
            return value;
        return systemManager.getDeviceById(value) || systemManager.getDeviceById(readDefaultValue());
    }
    // string type, so check if it is json.
    if (value && setting.json) {
        try {
            return JSON.parse(value);
        }
        catch (e) {
            return readDefaultValue();
        }
    }
    return value || readDefaultValue();
}
class StorageSettings {
    constructor(device, settings) {
        this.device = device;
        this.settings = settings;
        this.values = {};
        this.hasValue = {};
        for (const key of Object.keys(settings)) {
            const setting = settings[key];
            const rawGet = () => this.getItem(key);
            let get;
            if (setting.type !== 'clippath') {
                get = rawGet;
            }
            else {
                // maybe need a mapPut. clippath is the only complex type at the moment.
                get = () => {
                    try {
                        return JSON.parse(rawGet());
                    }
                    catch (e) {
                    }
                };
            }
            Object.defineProperty(this.values, key, {
                get,
                set: value => this.putSetting(key, value),
                enumerable: true,
            });
            Object.defineProperty(this.hasValue, key, {
                get: () => this.device.storage.getItem(key) != null,
                enumerable: true,
            });
        }
    }
    get keys() {
        const ret = {};
        for (const key of Object.keys(this.settings)) {
            ret[key] = key;
        }
        return ret;
    }
    async getSettings() {
        const onGet = await this.options?.onGet?.();
        const ret = [];
        for (const [key, setting] of Object.entries(this.settings)) {
            let s = Object.assign({}, setting);
            if (onGet?.[key])
                s = Object.assign(s, onGet[key]);
            if (s.onGet)
                s = Object.assign(s, await s.onGet());
            if (s.hide || await this.options?.hide?.[key]?.())
                continue;
            s.key = key;
            s.value = this.getItemInternal(key, s, true);
            ret.push(s);
            delete s.onPut;
            delete s.onGet;
            delete s.mapPut;
            delete s.mapGet;
        }
        return ret;
    }
    async putSetting(key, value) {
        const setting = this.settings[key];
        let oldValue;
        if (setting)
            oldValue = this.getItemInternal(key, setting);
        return this.putSettingInternal(setting, oldValue, key, value);
    }
    putSettingInternal(setting, oldValue, key, value) {
        if (!setting?.noStore) {
            if (setting?.mapPut)
                value = setting.mapPut(oldValue, value);
            // nullish values should be removed, since Storage can't persist them correctly.
            if (value == null)
                this.device.storage.removeItem(key);
            else if (typeof value === 'object')
                this.device.storage.setItem(key, JSON.stringify(value));
            else
                this.device.storage.setItem(key, value?.toString());
        }
        setting?.onPut?.(oldValue, value);
        this.device.onDeviceEvent(_1.ScryptedInterface.Settings, undefined);
    }
    getItemInternal(key, setting, rawDevice) {
        if (!setting)
            return this.device.storage.getItem(key);
        const readDefaultValue = () => {
            if (setting.persistedDefaultValue) {
                this.putSettingInternal(setting, undefined, key, setting.persistedDefaultValue);
                return setting.persistedDefaultValue;
            }
            return setting.defaultValue;
        };
        const ret = parseValue(this.device.storage.getItem(key), setting, readDefaultValue, rawDevice);
        return setting.mapGet ? setting.mapGet(ret) : ret;
    }
    getItem(key) {
        return this.getItemInternal(key, this.settings[key]);
    }
}
exports.StorageSettings = StorageSettings;
//# sourceMappingURL=storage-settings.js.map